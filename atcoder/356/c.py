# N: 鍵の数, M: テストの数, K: ドアを開くために必要な正しい鍵の数を取得
N, M, K = map(int, input().split())

# C: 各テストで使用された鍵の本数, A: 各テストで使用された鍵のリスト, R: 各テストの結果
C, A, R = [], [], []

# M回のテストの入力を受け取り、C, A, Rに分けて格納
for _ in range(M):
    CAR = list(input().split())
    # 各テストの鍵の本数をCに追加
    C.append(int(CAR[0]))
    # 各テストで使用された鍵のリストをAに追加
    A.append(list(map(int, CAR[1:-1])))
    # 各テストの結果をRに追加 ('o' または 'x')
    R.append(CAR[-1])

# 有効な鍵の組み合わせの数をカウントする変数
ans = 0

# 鍵の組み合わせをビットマスクで表現し、全組み合わせ(2^N通り)を試す
for mask in range(1 << N):
    # 現在の組み合わせが条件を満たすかどうかを示すフラグ
    ok = True
    # 全てのテストケースをチェック
    for i in range(M):
        # 現在の組み合わせでテストiで正しい鍵の数をカウント
        cnt = 0
        for a in A[i]:
            cnt += (mask >> (a - 1)) & 1  # ビットシフトで鍵の存在を確認
        # テスト結果と鍵の数が矛盾していないか確認
        ok &= (cnt >= K) == (R[i] == "o")
    # 現在の組み合わせが全てのテスト条件を満たしていればカウントを増やす
    ans += ok

# 結果を出力 (条件を満たす鍵の組み合わせの数)
print(ans)
