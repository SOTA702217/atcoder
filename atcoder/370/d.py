# 問題文
# 縦 
# H マス、横 
# W マスのグリッドがあります。上から 
# i 行目、左から 
# j 列目のマスを 
# (i,j) と表します。
# はじめ、全てのマスには壁が 
# 1 個ずつ立てられています。
# 以下で説明されるクエリを 
# Q 個与えられる順に処理した後に、残っている壁の個数を求めてください。

# q 番目のクエリでは整数 
# R 
# q
# ​
#  ,C 
# q
# ​
#   が与えられます。
# あなたは 
# (R 
# q
# ​
#  ,C 
# q
# ​
#  ) に爆弾を置いて壁を爆破します。その結果、以下の処理が行われます。

# (R 
# q
# ​
#  ,C 
# q
# ​
#  ) に壁が存在する場合は、その壁を破壊して処理を終了する。
# (R 
# q
# ​
#  ,C 
# q
# ​
#  ) に壁が存在しない場合は、
# (R 
# q
# ​
#  ,C 
# q
# ​
#  ) から上下左右に見て最初に現れる壁を破壊する。厳密に述べると、以下の 
# 4 個の処理が同時に行われる。
# (i,C 
# q
# ​
#  ) に壁が存在して 
# (k,C 
# q
# ​
#  ) 
# (i<k<R 
# q
# ​
#  ) に壁が存在しないような 
# i<R 
# q
# ​
#   が存在する時、
# (i,C 
# q
# ​
#  ) に存在する壁を破壊する。
# (i,C 
# q
# ​
#  ) に壁が存在して 
# (k,C 
# q
# ​
#  ) 
# (R 
# q
# ​
#  <k<i) に壁が存在しないような 
# i>R 
# q
# ​
#   が存在する時、
# (i,C 
# q
# ​
#  ) に存在する壁を破壊する。
# (R 
# q
# ​
#  ,j) に壁が存在して 
# (R 
# q
# ​
#  ,k) 
# (j<k<C 
# q
# ​
#  ) に壁が存在しないような 
# j<C 
# q
# ​
#   が存在する時、
# (R 
# q
# ​
#  ,j) に存在する壁を破壊する。
# (R 
# q
# ​
#  ,j) に壁が存在して 
# (R 
# q
# ​
#  ,k) 
# (C 
# q
# ​
#  <k<j) に壁が存在しないような 
# j>C 
# q
# ​
#   が存在する時、
# (R 
# q
# ​
#  ,j) に存在する壁を破壊する。
# 制約
# 1≤H,W
# H×W≤4×10 
# 5
 
# 1≤Q≤2×10 
# 5
 
# 1≤R 
# q
# ​
#  ≤H
# 1≤C 
# q
# ​
#  ≤W
# 入力される値は全て整数
# 入力
# 入力は以下の形式で標準入力から与えられる。

# H 
# W 
# Q
# R 
# 1
# ​
  
# C 
# 1
# ​
 
# R 
# 2
# ​
  
# C 
# 2
# ​
 
# ⋮
# R 
# Q
# ​
  
# C 
# Q
# ​
 
# 出力
# クエリを全て処理した後に、残っている壁の個数を出力せよ。

H,W,Q=map(int,input().split())
R=[]
C=[]
S=[[0]*W for i in range(H)]

for i in Q:
    r,c=map(int,input().split())
    R.append(r)
    C.append(c)

for i in range(Q):
    S[R[i]-S[R[i]][C[i]]][C[i]-[R[i]][C[i]]]+=1
    S[R[i]-1][C[i]-1]+=1
    